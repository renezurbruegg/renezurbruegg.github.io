<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>flask_app.Driver.ADS8885 API documentation</title>
<meta name="description" content="Driver for the ADS8885 chip" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flask_app.Driver.ADS8885</code></h1>
</header>
<section id="section-intro">
<p>Driver for the ADS8885 chip</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34; Driver for the ADS8885 chip &#34;&#34;&#34;
import logging

logger = logging.getLogger(__name__)

try:
    import smbus
except ImportError:
    def _getBus(self, num):
        return self
    def read_word_data(self, adress, cmd):
        logger.debug(&#34;Mock Object -- read word data: addrress&#34; + str(adress) + &#34; cmd: &#34; + str(cmd))
        return 0
    def write_word_data(self, device_address, mode, value):
        logger.debug(&#34;Sendind word data emulation: to: &#34; + str(device_address) + &#34; mode: &#34; + str(mode)  + &#34; value: &#34; + str(value));

    obj = type(&#39;&#39;,(object,),{&#39;read_word_data&#39;:read_word_data,&#39;SMBus&#39;:_getBus,&#39;write_word_data&#39;:write_word_data})()
    smbus = obj
try:
    import spidev
    simul = False
except ImportError:
    simul = True
    logger.error(&#34;could not import spidev&#34;)
try:
    import RPi.GPIO as GPIO
except ImportError:
    simul = True
    logger.error(&#34;could not import GPIO&#34;)
# from .PCAL6416 import PCAL6416
# from .PCAL6416 import PinAssignment

import random

SPI_MOSI = 10
SPI_MISO = 9
SPI_CLK = 11


class ResolutionScaler:
    &#34;&#34;&#34; Class that offers a simple transform function. &lt;br&gt;
        Used to alibrate a ADS8885 chip. &lt;br&gt;
        The getScaledValue returns the real applied value before the voltage devider for a measured Value of the ADS chip.
    &#34;&#34;&#34;
    def __init__(self, multiplier, offset):
        self.multiplier = multiplier
        self.offset = offset

    def getScaledValue(self, value):
        &#34;&#34;&#34;Returns the real applied value before the voltage devider that corresponds to a measured value of the ADS chip.&#34;&#34;&#34;
        return self.multiplier * value + self.offset


class ADS8885:
    &#34;&#34;&#34;
    A class used to represent the ADS8885 Chip.
    ...

    Attributes
    ----------
    pin1,pin2:  integer which represents the pinnumber of the PCAL chip to control the &lt;br&gt;
                -VSel1/2 pin of the corresponding TS5A3359DCUR chip for the voltage measurement &lt;br&gt;
                -IRngSel1/2 pin used for the current measurement &lt;br&gt;
    measurement ==0 voltage measurement &lt;br&gt;
                ==1 current measurement &lt;br&gt;
    &#34;&#34;&#34;
    voltageMap = {
        1 : {
            &#34;unit&#34;:&#34;mV&#34;,
            &#34;max&#34;:50
        },
        2 : {
            &#34;unit&#34;:&#34;mV&#34;,
            &#34;max&#34;:500
        },
        3 : {
            &#34;unit&#34;:&#34;V&#34;,
            &#34;max&#34;:5
        }
    }
    currentMap = {
        1 : {
            &#34;unit&#34;:&#34;uA&#34;,
            &#34;max&#34;:500
        },
        2 : {
            &#34;unit&#34;:&#34;mA&#34;,
            &#34;max&#34;:50
        }
    }


    def __init__(self, name, measurement, pinAss1, pinAss2, ioExpander, cspin, resolutionScalers, vref = 2.5):
        self.name = name
        self.vref = vref
        self.pinAss1 = pinAss1
        self.pinAss2 = pinAss2
        self.ioExpander = ioExpander
        self.resolution = 1
        self.cspin = cspin
        self.measurement = measurement
        self.autoResolution=False

        self.resolutionScalers = resolutionScalers

        if(simul == False):
            GPIO.setup(self.cspin, GPIO.OUT, initial = GPIO.LOW)
            self.ioExpander.setToOutputPinAssignment(pinAss1)
            self.ioExpander.setToOutputPinAssignment(pinAss2)
        #Voltage measurement
        if(measurement == 0):
            self.resolutionMap = self.voltageMap
        else:
            self.resolutionMap = self.currentMap





        # if (simul==False):
        #     self.spi = spidev.SpiDev()
        #     # self.spi.bits_per_word = 8
        #     self.spi.open(0,1)
        #     self.spi.max_speed_hz = 7629 #Todo tweek
        #     self.spi.mode = 0b10
        #     self.spi.cshigh = True
        #     #self.spi.no_cs = True
        #     #self.spi.lsbfirst = True
        #     GPIO.setup(self.cspin, GPIO.OUT)

    def getVoltage(self):
        &#34;&#34;&#34; return the voltage that is measured by the ADS chip.
        This voltage needs to be scaled up using the scaleToResolution function, to get the real applied voltage.&#34;&#34;&#34;
        # print(&#34;getVoltage in: &#34; + self.name)

        if(simul):
            return random.randint(0,  int(self.vref))
            # return random.randint(0,self.getMaxRange()) / 100

        data = self.getAdcValue()

        # print(&#34;Got data &#34; + bin(data))
        #
        # st = bin(data) + (18-(len(bin(data))-2))*&#34;0&#34;;
        #
        # print(&#34;n data : &#34; + st,2)
        # # 0000 - 01ffff -&gt; POS
        # # 1000 - 11fffff -&gt; neg
        # print(st)
        # # data = 0x20000
        MSB = (int)((data &amp; (0b1 &lt;&lt; 17)) != 0)
        valToXor = (0x3FFFF * MSB)
        xored = (data ^ valToXor)
        val = xored + MSB

        # print(val)
        # print(&#34;xored: &#34; + bin(xored))


        maxVal = 0x1FFFF
        # print(&#34;maxVal: &#34; + str(maxVal))

        ratio = (val / maxVal)

        value = self.vref * ratio
        if(MSB):
            value *= -1

        # logger.debug(&#34;value: &#34; + str(value) + &#34;ratio: &#34; + str(ratio))
        # print(&#34;first bit: &#34; + str(data &amp; (0b1 &lt;&lt; 17)) == 0)

        return (-1) * value;

    def getVoltageFast(self):
        &#34;&#34;&#34; Fast implementation of the getVoltage() function &#34;&#34;&#34;
        data = self.getAdcValue()

        MSB = (bool)((data &amp; (0b1 &lt;&lt; 17)) != 0)
        val = (data ^  (0x3FFFF * MSB)) + MSB

        value = self.vref * (val / 0x1FFFF)

        if(MSB == False):
                return -value
        return value

    def scaleToResolution(self, value):
        &#34;&#34;&#34; scales a measured value from the ADS chip to the real applied value using internal ResolutionScaler objects that are set when creating this class&#34;&#34;&#34;
        # print(self.name + &#34; get scale to resolution for value : &#34; + str(value))
        # print(self.resolution)
        # print(self.resolutionScalers[self.resolution].multiplier)
        # print(self.resolutionScalers[self.resolution].offset)
        # print(&#34;ret: &#34; + str(self.resolutionScalers[self.resolution].getScaledValue(value)))
        return self.resolutionScalers[self.resolution].getScaledValue(value)
        # # self.calibrationMap[self.resolution]
        # return self.muliplier * value + self.offset;
        # # return value
        # # tmp = 0.0114*value**2 + 1.2688 * value + 2.0662
        # # if(self.name == &#34;vm1&#34;):
        # #     return value * 2.3307 - 0.1192 #* 3.133 - 40.6;
        # # elif(self.name == &#34;vm2&#34;):
        # #     return value * 2.3487 + 0.0375 #* 3.133 - 40.6;
        # # return value;

    def getMaxRange(self):
        &#34;&#34;&#34; Return the max value that can be measured in this range&#34;&#34;&#34;
        return self.resolutionMap[self.resolution][&#34;max&#34;]

    def getUnit(self):
        &#34;&#34;&#34; Return the unit of this measurement&#34;&#34;&#34;
        return self.resolutionMap[self.resolution][&#34;unit&#34;]

    def getName(self):
        &#34;&#34;&#34; Returns the name of this measurement device&#34;&#34;&#34;
        return self.name

    def getAdcValue(self):
        &#34;&#34;&#34; gets the value of the ADS Chip. currently using an ugly SPI emulation using GPIO pins.
        TODO: Fix errata of PCB and then use SPI library
        &#34;&#34;&#34;
        if(simul):
            return random.randint(0,self.getMaxRange()) / 100

        LOW = GPIO.LOW
        HIGH = GPIO.HIGH

        GPIO.output(SPI_MOSI, HIGH)
        GPIO.output(SPI_CLK, LOW) # Start with clock low
        GPIO.output(self.cspin, HIGH)  # Enable chip

        for i in range(8):  # Send bit pattern starting from bit b4
            GPIO.output(SPI_CLK, HIGH) # Clock pulse
            GPIO.output(SPI_CLK, LOW)

        GPIO.output(SPI_MOSI, LOW)
        GPIO.output(SPI_CLK, LOW)
        GPIO.output(SPI_CLK, LOW)

        # Get reply
        data = 0
        for i in range(18):  # Read 11 bits and insert at right
            GPIO.output(SPI_CLK, HIGH)  # Clock pulse
            data &lt;&lt;= 1  # Shift left, LSB = 0
            if GPIO.input(SPI_MISO): # If high, LSB = 1,
                data |= 0x1
            GPIO.output(SPI_CLK, LOW)

        GPIO.output(self.cspin, LOW) # Disable chip

        return data;

    def setAutoResolution(self, autoResolution):
        &#34;&#34;&#34; Enables the auto resolution function for this chip&#34;&#34;&#34;
        self.autoResolution=autoResolution

    def maxResolution(self):
        &#34;&#34;&#34; return true if max resolution of the device is reached &#34;&#34;&#34;
        reached= False
        if self.measurement==0:
            if self.resolution==3:
                reached=True
        if self.measurement==1:
            if self.resolution==2:
                reached=True
        return reached

    def minResolution(self):
        &#34;&#34;&#34; return true if min resolution of the device is reached &#34;&#34;&#34;
        reached= (self.resolution==1)
        return reached


    def setResolution(self,resolution):
        &#34;&#34;&#34; Sets the resolution of this device. &lt;br&gt;
            [V]: 1 -&gt; 50mV, 2 -&gt; 500mV, 3 -&gt; 5V &lt;br&gt;
            [A]: 1 -&gt; 500uA, 2 -&gt; 50mA
        &#34;&#34;&#34;
        logger.debug(&#34;set resolution: name: &#34; +str(self.name) + &#34; resolution: &#34; + str(resolution))
        self.resolution = resolution
        if self.measurement==0:
            #resolution = 50mV
            if resolution== 1:
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)

            #resolution =500mV
            elif resolution== 2:
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)

            #resolution = 5V
            elif resolution== 3:
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss2)

            else:
                raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)


        elif (self.measurement == 1):
            #resolution=500uA
            if resolution ==1:
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss2)
            #resolution=50mA
            elif resolution==2:
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)
            else:
                raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)


    def reachedResolutionMax(self, value):
        &#34;&#34;&#34;
        returns true if voltage is close to upper resolution limit
        &#34;&#34;&#34;
        tolerance=0
        reached=False
        resolution= self.resolution
        absVal = abs(value)
        if self.measurement==0:
            #resolution = 50mV
            if resolution== 1:
                reached= (absVal&gt;=(50-tolerance))

            #resolution =500mV
            elif resolution== 2:
                reached= (absVal&gt;=(500-tolerance))

            #resolution = 5V
            elif resolution== 3:
                reached= (absVal&gt;=(5-tolerance))

            else:
                raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)

        elif self.measurement == 1:
            #resolution=500uA
            if resolution ==1:
                reached= (absVal&gt;=(500-tolerance))

            #resolution=50mA
            elif resolution==2:
                reached= (absVal&gt;=(50-tolerance))

            else:
                raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)

        else:
                raise ValueError(&#39;measurement for voltage measurement must be 0, measurement for current measurement must be 1&#39;)
        return reached

    def getDebugInfos(self):
        &#34;&#34;&#34; Returns debug information about the chip (name, current resolution, maxRange etc.) &#34;&#34;&#34;
        ans = self.getName() + &#34; : &#34; + str(self.getMaxRange()) + &#34; : &#34; + str(self.resolution) + &#34;\n&#34;;
        ans += &#34;ADC values: &#34; +  str(self.getVoltage()) + &#34; adc val fast &#34; + str(self.getVoltageFast())
        return ans;

    def reachedResolutionMin(self, value):
        &#34;&#34;&#34;
        Returns true if voltage is close to lower resolution limit
        &#34;&#34;&#34;
        tolerance=0
        reached=False
        absVal = abs(value)
        resolution= self.resolution
        if self.measurement==0:
            #resolution = 50mV
            if resolution== 1:
                reached=False

            #resolution =500mV
            elif resolution== 2:
                reached= (absVal&lt;=(50+tolerance))

            #resolution = 5V
            elif resolution== 3:
                reached= (absVal&lt;=(0.5+tolerance))

            else:
                raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)

        elif self.measurement == 1:
            #resolution=500uA
            if resolution ==1:
                reached= False

            #resolution=50mA
            elif resolution==2:
                reached= (absVal&lt;=(0.5+tolerance))

            else:
                raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)

        else:
                raise ValueError(&#39;measurement for voltage measurement must be 0, measurement for current measurement must be 1&#39;)
        return reached</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="flask_app.Driver.ADS8885.read_word_data"><code class="name flex">
<span>def <span class="ident">read_word_data</span></span>(<span>self, adress, cmd)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_word_data(self, adress, cmd):
    logger.debug(&#34;Mock Object -- read word data: addrress&#34; + str(adress) + &#34; cmd: &#34; + str(cmd))
    return 0</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.write_word_data"><code class="name flex">
<span>def <span class="ident">write_word_data</span></span>(<span>self, device_address, mode, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_word_data(self, device_address, mode, value):
    logger.debug(&#34;Sendind word data emulation: to: &#34; + str(device_address) + &#34; mode: &#34; + str(mode)  + &#34; value: &#34; + str(value));</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flask_app.Driver.ADS8885.ADS8885"><code class="flex name class">
<span>class <span class="ident">ADS8885</span></span>
<span>(</span><span>name, measurement, pinAss1, pinAss2, ioExpander, cspin, resolutionScalers, vref=2.5)</span>
</code></dt>
<dd>
<section class="desc"><p>A class used to represent the ADS8885 Chip.
&hellip;</p>
<h2 id="attributes">Attributes</h2>
<p>pin1,pin2:
integer which represents the pinnumber of the PCAL chip to control the <br>
-VSel1/2 pin of the corresponding TS5A3359DCUR chip for the voltage measurement <br>
-IRngSel1/2 pin used for the current measurement <br>
measurement ==0 voltage measurement <br>
==1 current measurement <br></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ADS8885:
    &#34;&#34;&#34;
    A class used to represent the ADS8885 Chip.
    ...

    Attributes
    ----------
    pin1,pin2:  integer which represents the pinnumber of the PCAL chip to control the &lt;br&gt;
                -VSel1/2 pin of the corresponding TS5A3359DCUR chip for the voltage measurement &lt;br&gt;
                -IRngSel1/2 pin used for the current measurement &lt;br&gt;
    measurement ==0 voltage measurement &lt;br&gt;
                ==1 current measurement &lt;br&gt;
    &#34;&#34;&#34;
    voltageMap = {
        1 : {
            &#34;unit&#34;:&#34;mV&#34;,
            &#34;max&#34;:50
        },
        2 : {
            &#34;unit&#34;:&#34;mV&#34;,
            &#34;max&#34;:500
        },
        3 : {
            &#34;unit&#34;:&#34;V&#34;,
            &#34;max&#34;:5
        }
    }
    currentMap = {
        1 : {
            &#34;unit&#34;:&#34;uA&#34;,
            &#34;max&#34;:500
        },
        2 : {
            &#34;unit&#34;:&#34;mA&#34;,
            &#34;max&#34;:50
        }
    }


    def __init__(self, name, measurement, pinAss1, pinAss2, ioExpander, cspin, resolutionScalers, vref = 2.5):
        self.name = name
        self.vref = vref
        self.pinAss1 = pinAss1
        self.pinAss2 = pinAss2
        self.ioExpander = ioExpander
        self.resolution = 1
        self.cspin = cspin
        self.measurement = measurement
        self.autoResolution=False

        self.resolutionScalers = resolutionScalers

        if(simul == False):
            GPIO.setup(self.cspin, GPIO.OUT, initial = GPIO.LOW)
            self.ioExpander.setToOutputPinAssignment(pinAss1)
            self.ioExpander.setToOutputPinAssignment(pinAss2)
        #Voltage measurement
        if(measurement == 0):
            self.resolutionMap = self.voltageMap
        else:
            self.resolutionMap = self.currentMap





        # if (simul==False):
        #     self.spi = spidev.SpiDev()
        #     # self.spi.bits_per_word = 8
        #     self.spi.open(0,1)
        #     self.spi.max_speed_hz = 7629 #Todo tweek
        #     self.spi.mode = 0b10
        #     self.spi.cshigh = True
        #     #self.spi.no_cs = True
        #     #self.spi.lsbfirst = True
        #     GPIO.setup(self.cspin, GPIO.OUT)

    def getVoltage(self):
        &#34;&#34;&#34; return the voltage that is measured by the ADS chip.
        This voltage needs to be scaled up using the scaleToResolution function, to get the real applied voltage.&#34;&#34;&#34;
        # print(&#34;getVoltage in: &#34; + self.name)

        if(simul):
            return random.randint(0,  int(self.vref))
            # return random.randint(0,self.getMaxRange()) / 100

        data = self.getAdcValue()

        # print(&#34;Got data &#34; + bin(data))
        #
        # st = bin(data) + (18-(len(bin(data))-2))*&#34;0&#34;;
        #
        # print(&#34;n data : &#34; + st,2)
        # # 0000 - 01ffff -&gt; POS
        # # 1000 - 11fffff -&gt; neg
        # print(st)
        # # data = 0x20000
        MSB = (int)((data &amp; (0b1 &lt;&lt; 17)) != 0)
        valToXor = (0x3FFFF * MSB)
        xored = (data ^ valToXor)
        val = xored + MSB

        # print(val)
        # print(&#34;xored: &#34; + bin(xored))


        maxVal = 0x1FFFF
        # print(&#34;maxVal: &#34; + str(maxVal))

        ratio = (val / maxVal)

        value = self.vref * ratio
        if(MSB):
            value *= -1

        # logger.debug(&#34;value: &#34; + str(value) + &#34;ratio: &#34; + str(ratio))
        # print(&#34;first bit: &#34; + str(data &amp; (0b1 &lt;&lt; 17)) == 0)

        return (-1) * value;

    def getVoltageFast(self):
        &#34;&#34;&#34; Fast implementation of the getVoltage() function &#34;&#34;&#34;
        data = self.getAdcValue()

        MSB = (bool)((data &amp; (0b1 &lt;&lt; 17)) != 0)
        val = (data ^  (0x3FFFF * MSB)) + MSB

        value = self.vref * (val / 0x1FFFF)

        if(MSB == False):
                return -value
        return value

    def scaleToResolution(self, value):
        &#34;&#34;&#34; scales a measured value from the ADS chip to the real applied value using internal ResolutionScaler objects that are set when creating this class&#34;&#34;&#34;
        # print(self.name + &#34; get scale to resolution for value : &#34; + str(value))
        # print(self.resolution)
        # print(self.resolutionScalers[self.resolution].multiplier)
        # print(self.resolutionScalers[self.resolution].offset)
        # print(&#34;ret: &#34; + str(self.resolutionScalers[self.resolution].getScaledValue(value)))
        return self.resolutionScalers[self.resolution].getScaledValue(value)
        # # self.calibrationMap[self.resolution]
        # return self.muliplier * value + self.offset;
        # # return value
        # # tmp = 0.0114*value**2 + 1.2688 * value + 2.0662
        # # if(self.name == &#34;vm1&#34;):
        # #     return value * 2.3307 - 0.1192 #* 3.133 - 40.6;
        # # elif(self.name == &#34;vm2&#34;):
        # #     return value * 2.3487 + 0.0375 #* 3.133 - 40.6;
        # # return value;

    def getMaxRange(self):
        &#34;&#34;&#34; Return the max value that can be measured in this range&#34;&#34;&#34;
        return self.resolutionMap[self.resolution][&#34;max&#34;]

    def getUnit(self):
        &#34;&#34;&#34; Return the unit of this measurement&#34;&#34;&#34;
        return self.resolutionMap[self.resolution][&#34;unit&#34;]

    def getName(self):
        &#34;&#34;&#34; Returns the name of this measurement device&#34;&#34;&#34;
        return self.name

    def getAdcValue(self):
        &#34;&#34;&#34; gets the value of the ADS Chip. currently using an ugly SPI emulation using GPIO pins.
        TODO: Fix errata of PCB and then use SPI library
        &#34;&#34;&#34;
        if(simul):
            return random.randint(0,self.getMaxRange()) / 100

        LOW = GPIO.LOW
        HIGH = GPIO.HIGH

        GPIO.output(SPI_MOSI, HIGH)
        GPIO.output(SPI_CLK, LOW) # Start with clock low
        GPIO.output(self.cspin, HIGH)  # Enable chip

        for i in range(8):  # Send bit pattern starting from bit b4
            GPIO.output(SPI_CLK, HIGH) # Clock pulse
            GPIO.output(SPI_CLK, LOW)

        GPIO.output(SPI_MOSI, LOW)
        GPIO.output(SPI_CLK, LOW)
        GPIO.output(SPI_CLK, LOW)

        # Get reply
        data = 0
        for i in range(18):  # Read 11 bits and insert at right
            GPIO.output(SPI_CLK, HIGH)  # Clock pulse
            data &lt;&lt;= 1  # Shift left, LSB = 0
            if GPIO.input(SPI_MISO): # If high, LSB = 1,
                data |= 0x1
            GPIO.output(SPI_CLK, LOW)

        GPIO.output(self.cspin, LOW) # Disable chip

        return data;

    def setAutoResolution(self, autoResolution):
        &#34;&#34;&#34; Enables the auto resolution function for this chip&#34;&#34;&#34;
        self.autoResolution=autoResolution

    def maxResolution(self):
        &#34;&#34;&#34; return true if max resolution of the device is reached &#34;&#34;&#34;
        reached= False
        if self.measurement==0:
            if self.resolution==3:
                reached=True
        if self.measurement==1:
            if self.resolution==2:
                reached=True
        return reached

    def minResolution(self):
        &#34;&#34;&#34; return true if min resolution of the device is reached &#34;&#34;&#34;
        reached= (self.resolution==1)
        return reached


    def setResolution(self,resolution):
        &#34;&#34;&#34; Sets the resolution of this device. &lt;br&gt;
            [V]: 1 -&gt; 50mV, 2 -&gt; 500mV, 3 -&gt; 5V &lt;br&gt;
            [A]: 1 -&gt; 500uA, 2 -&gt; 50mA
        &#34;&#34;&#34;
        logger.debug(&#34;set resolution: name: &#34; +str(self.name) + &#34; resolution: &#34; + str(resolution))
        self.resolution = resolution
        if self.measurement==0:
            #resolution = 50mV
            if resolution== 1:
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)

            #resolution =500mV
            elif resolution== 2:
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)

            #resolution = 5V
            elif resolution== 3:
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss2)

            else:
                raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)


        elif (self.measurement == 1):
            #resolution=500uA
            if resolution ==1:
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss2)
            #resolution=50mA
            elif resolution==2:
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
                self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)
            else:
                raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)


    def reachedResolutionMax(self, value):
        &#34;&#34;&#34;
        returns true if voltage is close to upper resolution limit
        &#34;&#34;&#34;
        tolerance=0
        reached=False
        resolution= self.resolution
        absVal = abs(value)
        if self.measurement==0:
            #resolution = 50mV
            if resolution== 1:
                reached= (absVal&gt;=(50-tolerance))

            #resolution =500mV
            elif resolution== 2:
                reached= (absVal&gt;=(500-tolerance))

            #resolution = 5V
            elif resolution== 3:
                reached= (absVal&gt;=(5-tolerance))

            else:
                raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)

        elif self.measurement == 1:
            #resolution=500uA
            if resolution ==1:
                reached= (absVal&gt;=(500-tolerance))

            #resolution=50mA
            elif resolution==2:
                reached= (absVal&gt;=(50-tolerance))

            else:
                raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)

        else:
                raise ValueError(&#39;measurement for voltage measurement must be 0, measurement for current measurement must be 1&#39;)
        return reached

    def getDebugInfos(self):
        &#34;&#34;&#34; Returns debug information about the chip (name, current resolution, maxRange etc.) &#34;&#34;&#34;
        ans = self.getName() + &#34; : &#34; + str(self.getMaxRange()) + &#34; : &#34; + str(self.resolution) + &#34;\n&#34;;
        ans += &#34;ADC values: &#34; +  str(self.getVoltage()) + &#34; adc val fast &#34; + str(self.getVoltageFast())
        return ans;

    def reachedResolutionMin(self, value):
        &#34;&#34;&#34;
        Returns true if voltage is close to lower resolution limit
        &#34;&#34;&#34;
        tolerance=0
        reached=False
        absVal = abs(value)
        resolution= self.resolution
        if self.measurement==0:
            #resolution = 50mV
            if resolution== 1:
                reached=False

            #resolution =500mV
            elif resolution== 2:
                reached= (absVal&lt;=(50+tolerance))

            #resolution = 5V
            elif resolution== 3:
                reached= (absVal&lt;=(0.5+tolerance))

            else:
                raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)

        elif self.measurement == 1:
            #resolution=500uA
            if resolution ==1:
                reached= False

            #resolution=50mA
            elif resolution==2:
                reached= (absVal&lt;=(0.5+tolerance))

            else:
                raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)

        else:
                raise ValueError(&#39;measurement for voltage measurement must be 0, measurement for current measurement must be 1&#39;)
        return reached</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="flask_app.Driver.ADS8885.ADS8885.currentMap"><code class="name">var <span class="ident">currentMap</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.voltageMap"><code class="name">var <span class="ident">voltageMap</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="flask_app.Driver.ADS8885.ADS8885.getAdcValue"><code class="name flex">
<span>def <span class="ident">getAdcValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>gets the value of the ADS Chip. currently using an ugly SPI emulation using GPIO pins.
TODO: Fix errata of PCB and then use SPI library</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getAdcValue(self):
    &#34;&#34;&#34; gets the value of the ADS Chip. currently using an ugly SPI emulation using GPIO pins.
    TODO: Fix errata of PCB and then use SPI library
    &#34;&#34;&#34;
    if(simul):
        return random.randint(0,self.getMaxRange()) / 100

    LOW = GPIO.LOW
    HIGH = GPIO.HIGH

    GPIO.output(SPI_MOSI, HIGH)
    GPIO.output(SPI_CLK, LOW) # Start with clock low
    GPIO.output(self.cspin, HIGH)  # Enable chip

    for i in range(8):  # Send bit pattern starting from bit b4
        GPIO.output(SPI_CLK, HIGH) # Clock pulse
        GPIO.output(SPI_CLK, LOW)

    GPIO.output(SPI_MOSI, LOW)
    GPIO.output(SPI_CLK, LOW)
    GPIO.output(SPI_CLK, LOW)

    # Get reply
    data = 0
    for i in range(18):  # Read 11 bits and insert at right
        GPIO.output(SPI_CLK, HIGH)  # Clock pulse
        data &lt;&lt;= 1  # Shift left, LSB = 0
        if GPIO.input(SPI_MISO): # If high, LSB = 1,
            data |= 0x1
        GPIO.output(SPI_CLK, LOW)

    GPIO.output(self.cspin, LOW) # Disable chip

    return data;</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.getDebugInfos"><code class="name flex">
<span>def <span class="ident">getDebugInfos</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns debug information about the chip (name, current resolution, maxRange etc.)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getDebugInfos(self):
    &#34;&#34;&#34; Returns debug information about the chip (name, current resolution, maxRange etc.) &#34;&#34;&#34;
    ans = self.getName() + &#34; : &#34; + str(self.getMaxRange()) + &#34; : &#34; + str(self.resolution) + &#34;\n&#34;;
    ans += &#34;ADC values: &#34; +  str(self.getVoltage()) + &#34; adc val fast &#34; + str(self.getVoltageFast())
    return ans;</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.getMaxRange"><code class="name flex">
<span>def <span class="ident">getMaxRange</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the max value that can be measured in this range</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getMaxRange(self):
    &#34;&#34;&#34; Return the max value that can be measured in this range&#34;&#34;&#34;
    return self.resolutionMap[self.resolution][&#34;max&#34;]</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.getName"><code class="name flex">
<span>def <span class="ident">getName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the name of this measurement device</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getName(self):
    &#34;&#34;&#34; Returns the name of this measurement device&#34;&#34;&#34;
    return self.name</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.getUnit"><code class="name flex">
<span>def <span class="ident">getUnit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the unit of this measurement</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getUnit(self):
    &#34;&#34;&#34; Return the unit of this measurement&#34;&#34;&#34;
    return self.resolutionMap[self.resolution][&#34;unit&#34;]</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.getVoltage"><code class="name flex">
<span>def <span class="ident">getVoltage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>return the voltage that is measured by the ADS chip.
This voltage needs to be scaled up using the scaleToResolution function, to get the real applied voltage.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVoltage(self):
    &#34;&#34;&#34; return the voltage that is measured by the ADS chip.
    This voltage needs to be scaled up using the scaleToResolution function, to get the real applied voltage.&#34;&#34;&#34;
    # print(&#34;getVoltage in: &#34; + self.name)

    if(simul):
        return random.randint(0,  int(self.vref))
        # return random.randint(0,self.getMaxRange()) / 100

    data = self.getAdcValue()

    # print(&#34;Got data &#34; + bin(data))
    #
    # st = bin(data) + (18-(len(bin(data))-2))*&#34;0&#34;;
    #
    # print(&#34;n data : &#34; + st,2)
    # # 0000 - 01ffff -&gt; POS
    # # 1000 - 11fffff -&gt; neg
    # print(st)
    # # data = 0x20000
    MSB = (int)((data &amp; (0b1 &lt;&lt; 17)) != 0)
    valToXor = (0x3FFFF * MSB)
    xored = (data ^ valToXor)
    val = xored + MSB

    # print(val)
    # print(&#34;xored: &#34; + bin(xored))


    maxVal = 0x1FFFF
    # print(&#34;maxVal: &#34; + str(maxVal))

    ratio = (val / maxVal)

    value = self.vref * ratio
    if(MSB):
        value *= -1

    # logger.debug(&#34;value: &#34; + str(value) + &#34;ratio: &#34; + str(ratio))
    # print(&#34;first bit: &#34; + str(data &amp; (0b1 &lt;&lt; 17)) == 0)

    return (-1) * value;</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.getVoltageFast"><code class="name flex">
<span>def <span class="ident">getVoltageFast</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Fast implementation of the getVoltage() function</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getVoltageFast(self):
    &#34;&#34;&#34; Fast implementation of the getVoltage() function &#34;&#34;&#34;
    data = self.getAdcValue()

    MSB = (bool)((data &amp; (0b1 &lt;&lt; 17)) != 0)
    val = (data ^  (0x3FFFF * MSB)) + MSB

    value = self.vref * (val / 0x1FFFF)

    if(MSB == False):
            return -value
    return value</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.maxResolution"><code class="name flex">
<span>def <span class="ident">maxResolution</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>return true if max resolution of the device is reached</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def maxResolution(self):
    &#34;&#34;&#34; return true if max resolution of the device is reached &#34;&#34;&#34;
    reached= False
    if self.measurement==0:
        if self.resolution==3:
            reached=True
    if self.measurement==1:
        if self.resolution==2:
            reached=True
    return reached</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.minResolution"><code class="name flex">
<span>def <span class="ident">minResolution</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>return true if min resolution of the device is reached</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def minResolution(self):
    &#34;&#34;&#34; return true if min resolution of the device is reached &#34;&#34;&#34;
    reached= (self.resolution==1)
    return reached</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.reachedResolutionMax"><code class="name flex">
<span>def <span class="ident">reachedResolutionMax</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>returns true if voltage is close to upper resolution limit</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def reachedResolutionMax(self, value):
    &#34;&#34;&#34;
    returns true if voltage is close to upper resolution limit
    &#34;&#34;&#34;
    tolerance=0
    reached=False
    resolution= self.resolution
    absVal = abs(value)
    if self.measurement==0:
        #resolution = 50mV
        if resolution== 1:
            reached= (absVal&gt;=(50-tolerance))

        #resolution =500mV
        elif resolution== 2:
            reached= (absVal&gt;=(500-tolerance))

        #resolution = 5V
        elif resolution== 3:
            reached= (absVal&gt;=(5-tolerance))

        else:
            raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)

    elif self.measurement == 1:
        #resolution=500uA
        if resolution ==1:
            reached= (absVal&gt;=(500-tolerance))

        #resolution=50mA
        elif resolution==2:
            reached= (absVal&gt;=(50-tolerance))

        else:
            raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)

    else:
            raise ValueError(&#39;measurement for voltage measurement must be 0, measurement for current measurement must be 1&#39;)
    return reached</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.reachedResolutionMin"><code class="name flex">
<span>def <span class="ident">reachedResolutionMin</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns true if voltage is close to lower resolution limit</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def reachedResolutionMin(self, value):
    &#34;&#34;&#34;
    Returns true if voltage is close to lower resolution limit
    &#34;&#34;&#34;
    tolerance=0
    reached=False
    absVal = abs(value)
    resolution= self.resolution
    if self.measurement==0:
        #resolution = 50mV
        if resolution== 1:
            reached=False

        #resolution =500mV
        elif resolution== 2:
            reached= (absVal&lt;=(50+tolerance))

        #resolution = 5V
        elif resolution== 3:
            reached= (absVal&lt;=(0.5+tolerance))

        else:
            raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)

    elif self.measurement == 1:
        #resolution=500uA
        if resolution ==1:
            reached= False

        #resolution=50mA
        elif resolution==2:
            reached= (absVal&lt;=(0.5+tolerance))

        else:
            raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)

    else:
            raise ValueError(&#39;measurement for voltage measurement must be 0, measurement for current measurement must be 1&#39;)
    return reached</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.scaleToResolution"><code class="name flex">
<span>def <span class="ident">scaleToResolution</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>scales a measured value from the ADS chip to the real applied value using internal ResolutionScaler objects that are set when creating this class</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def scaleToResolution(self, value):
    &#34;&#34;&#34; scales a measured value from the ADS chip to the real applied value using internal ResolutionScaler objects that are set when creating this class&#34;&#34;&#34;
    # print(self.name + &#34; get scale to resolution for value : &#34; + str(value))
    # print(self.resolution)
    # print(self.resolutionScalers[self.resolution].multiplier)
    # print(self.resolutionScalers[self.resolution].offset)
    # print(&#34;ret: &#34; + str(self.resolutionScalers[self.resolution].getScaledValue(value)))
    return self.resolutionScalers[self.resolution].getScaledValue(value)</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.setAutoResolution"><code class="name flex">
<span>def <span class="ident">setAutoResolution</span></span>(<span>self, autoResolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Enables the auto resolution function for this chip</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setAutoResolution(self, autoResolution):
    &#34;&#34;&#34; Enables the auto resolution function for this chip&#34;&#34;&#34;
    self.autoResolution=autoResolution</code></pre>
</details>
</dd>
<dt id="flask_app.Driver.ADS8885.ADS8885.setResolution"><code class="name flex">
<span>def <span class="ident">setResolution</span></span>(<span>self, resolution)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the resolution of this device. <br>
[V]: 1 -&gt; 50mV, 2 -&gt; 500mV, 3 -&gt; 5V <br>
[A]: 1 -&gt; 500uA, 2 -&gt; 50mA</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setResolution(self,resolution):
    &#34;&#34;&#34; Sets the resolution of this device. &lt;br&gt;
        [V]: 1 -&gt; 50mV, 2 -&gt; 500mV, 3 -&gt; 5V &lt;br&gt;
        [A]: 1 -&gt; 500uA, 2 -&gt; 50mA
    &#34;&#34;&#34;
    logger.debug(&#34;set resolution: name: &#34; +str(self.name) + &#34; resolution: &#34; + str(resolution))
    self.resolution = resolution
    if self.measurement==0:
        #resolution = 50mV
        if resolution== 1:
            self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
            self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)

        #resolution =500mV
        elif resolution== 2:
            self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss1)
            self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)

        #resolution = 5V
        elif resolution== 3:
            self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
            self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss2)

        else:
            raise ValueError(&#39;resolution for voltage measurement must be 1 (for the 50mV range), 2 (for the 500mV range) or 3 (for the 5V range)&#39;)


    elif (self.measurement == 1):
        #resolution=500uA
        if resolution ==1:
            self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss1)
            self.ioExpander.setVoltageHighOnPinAssignment(self.pinAss2)
        #resolution=50mA
        elif resolution==2:
            self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss1)
            self.ioExpander.setVoltageLowOnPinAssignment(self.pinAss2)
        else:
            raise ValueError(&#39;resolution for current measurement must be 1 (for the 500uA range) or 2 (for the 50mA range)&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="flask_app.Driver.ADS8885.ResolutionScaler"><code class="flex name class">
<span>class <span class="ident">ResolutionScaler</span></span>
<span>(</span><span>multiplier, offset)</span>
</code></dt>
<dd>
<section class="desc"><p>Class that offers a simple transform function. <br>
Used to alibrate a ADS8885 chip. <br>
The getScaledValue returns the real applied value before the voltage devider for a measured Value of the ADS chip.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ResolutionScaler:
    &#34;&#34;&#34; Class that offers a simple transform function. &lt;br&gt;
        Used to alibrate a ADS8885 chip. &lt;br&gt;
        The getScaledValue returns the real applied value before the voltage devider for a measured Value of the ADS chip.
    &#34;&#34;&#34;
    def __init__(self, multiplier, offset):
        self.multiplier = multiplier
        self.offset = offset

    def getScaledValue(self, value):
        &#34;&#34;&#34;Returns the real applied value before the voltage devider that corresponds to a measured value of the ADS chip.&#34;&#34;&#34;
        return self.multiplier * value + self.offset</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="flask_app.Driver.ADS8885.ResolutionScaler.getScaledValue"><code class="name flex">
<span>def <span class="ident">getScaledValue</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the real applied value before the voltage devider that corresponds to a measured value of the ADS chip.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getScaledValue(self, value):
    &#34;&#34;&#34;Returns the real applied value before the voltage devider that corresponds to a measured value of the ADS chip.&#34;&#34;&#34;
    return self.multiplier * value + self.offset</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flask_app.Driver" href="index.html">flask_app.Driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="flask_app.Driver.ADS8885.read_word_data" href="#flask_app.Driver.ADS8885.read_word_data">read_word_data</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.write_word_data" href="#flask_app.Driver.ADS8885.write_word_data">write_word_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flask_app.Driver.ADS8885.ADS8885" href="#flask_app.Driver.ADS8885.ADS8885">ADS8885</a></code></h4>
<ul class="">
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.currentMap" href="#flask_app.Driver.ADS8885.ADS8885.currentMap">currentMap</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getAdcValue" href="#flask_app.Driver.ADS8885.ADS8885.getAdcValue">getAdcValue</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getDebugInfos" href="#flask_app.Driver.ADS8885.ADS8885.getDebugInfos">getDebugInfos</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getMaxRange" href="#flask_app.Driver.ADS8885.ADS8885.getMaxRange">getMaxRange</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getName" href="#flask_app.Driver.ADS8885.ADS8885.getName">getName</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getUnit" href="#flask_app.Driver.ADS8885.ADS8885.getUnit">getUnit</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getVoltage" href="#flask_app.Driver.ADS8885.ADS8885.getVoltage">getVoltage</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.getVoltageFast" href="#flask_app.Driver.ADS8885.ADS8885.getVoltageFast">getVoltageFast</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.maxResolution" href="#flask_app.Driver.ADS8885.ADS8885.maxResolution">maxResolution</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.minResolution" href="#flask_app.Driver.ADS8885.ADS8885.minResolution">minResolution</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.reachedResolutionMax" href="#flask_app.Driver.ADS8885.ADS8885.reachedResolutionMax">reachedResolutionMax</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.reachedResolutionMin" href="#flask_app.Driver.ADS8885.ADS8885.reachedResolutionMin">reachedResolutionMin</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.scaleToResolution" href="#flask_app.Driver.ADS8885.ADS8885.scaleToResolution">scaleToResolution</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.setAutoResolution" href="#flask_app.Driver.ADS8885.ADS8885.setAutoResolution">setAutoResolution</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.setResolution" href="#flask_app.Driver.ADS8885.ADS8885.setResolution">setResolution</a></code></li>
<li><code><a title="flask_app.Driver.ADS8885.ADS8885.voltageMap" href="#flask_app.Driver.ADS8885.ADS8885.voltageMap">voltageMap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="flask_app.Driver.ADS8885.ResolutionScaler" href="#flask_app.Driver.ADS8885.ResolutionScaler">ResolutionScaler</a></code></h4>
<ul class="">
<li><code><a title="flask_app.Driver.ADS8885.ResolutionScaler.getScaledValue" href="#flask_app.Driver.ADS8885.ResolutionScaler.getScaledValue">getScaledValue</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>